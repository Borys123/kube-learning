1. DOCS:

kubernetes.io/docs 
kubernetes.io/blog 

github.com/aquasecurity/trivy
falco.org/docs 
gitlab.com/apparmor/apparmor/-/wikis/Documentation

1. NetworkPolicies

deafault-deny-np.yaml

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: default-deny-all
  namespace: nptest
spec:
  podSelector: {}
  policyTypes:
- Ingress
- Egress

NetPols are additive - have a default deny, add rules allowing with others.

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-ingress 
  namespace: nptest 
spec:
  podSelector:
    matchLabels:
      app: nginx 
  policyTypes:
  - Ingress
  ingress:
  - from:
    - namespaceSelector:
      matchLabels:
        project: test
      podSelector:
        matchLabels:
          app: client
    ports:
    - protocol: TCP
      port: 80

apiVersion: networking.k8s.io/v1
kind: NetworkPolicy
metadata:
  name: nginx-ingress 
  namespace: nptest 
spec:
  podSelector:
    matchLabels:
      app: client 
  policyTypes:
  - Egress
  egress:
  - to:
    - namespaceSelector:
      matchLabels:
        project: test
      podSelector:
        matchLabels:
          app: nginx
    ports:
    - protocol: TCP
      port: 80

2. CIS Benchmark

k create -f both kube-bench files (control and worker job)

k log kube-bench-master > kube-bench-master.log
k log kube-bench-worker > kube-bench-worker.log 

/var/lib/kubelet/config.yaml 

3. Ingress TLS

user -> https -> ingress -> http -> service

openssl req -nodes -new -x509 -keyout tls-ingress.key -out tls-ingress.crt -subj "/CN=ingress.test" 

vi ingress-tls-secret.yaml
apiVersion: v1
kind: Secret 
type: kubernetes.io/tls 
metadata:
  name: ingress-tls
  namespace: ingresstest
data:
  tls.crt: |
    <base64-encoded cert data from tls-ingress.crt>
  tls.key: |
    <base64-encoded key data from tls-ingress.key>

tls-ingress.yaml

apiVersion: networking.k8s.io/v1
kind: Ingress
metadata:
  name: tls-ingress
  namespace: ingresstest
spec:
  tls:
  - hosts:
    - ingress.test 
    secretName: ingress-tls
  rules:
  - host: ingress.test
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: ingresstest-nginx-svc 
            port:
              number: 80

4. Attack surfaces (ports, gui tools, opportunities)

Securing Node Endpoints

Be aware of what ports your K8s nodes are using. Use network segmentation/firewalls to keep them safe!

6443 kube-apiserver
2379-2380 etcd
10250 kubelet API 
10251 kube-scheduler
10252 kube-controller-manager

Worker node listening ports:
10250 kubelet API
30000-32767 NodePort Services

Secure the GUI dashboard!
RBAC, maybe network segmentation, firewalls.

5. Verifying Kubernetes binaries

kubectl version --short --client

curl -LO "https://dl.k8s.io/v1.20.1/bin/linux/amd64/kubectl.sha256"

echo "$(<kubectl.sha256) /usr/bin/kubectl" | sha256sum --check

6. ServiceAccounts

If a container is comproimsed, an attacker can use it to acces K8s API. Only give necessary permissions to SAs.

Examine existing RoleBindings and ClusterRoleBindings to determine what permissions a SA has.

Design your RBAC setup in such a way that service accounts don't have unnecessary permissions.

You can bind multiple roles to an account. Keep roles separate, don't overload them with permissions.

You can bind CRs with RBs.

7. The Kubernetes API 

Limit user account permissions.
Limit network access to the KubeAPI.

8. Kubernetes updates

Keep K8s up to date.

Appr 1 year / 3 minor versions of patch support.

9. Host OS Security

Containers use OS namespaces to isolathe themselves from other containers and the host.

Host Namespaces | Container Namespaces - separation

You can configure pods to use the Host Namespace. Never do it unnecessarily.
spec:
  hostIPC: true      |
  hostNetwork: true  | all default to false
  hostPID: true      |

Privileged mode - allowes containers to access host-level resources and capabilities
                  much like a non-container process running directly on the host.

spec:
  containers:
    - securityContext:
        privileged: true

10. IAM Roles

Containers may be able to access IAM credentials.
Use principle of least privilege. 
If K8s doesn't use IAM, block access to (for EC2, IP address 169.254.169.254)

11. Network-Level Security 

Limit access to the cluster network from outside of the cluster.

By default, anyone who can access the cluster network, can communicate with all Pods and Svcs in the cluster.

When possible, limit access to the cluster network from outside. 

12. AppArmor

Linux Security kernel module. Provides granular access control for programs running on Linux systems. Use AppArmor to control
and limit what a program can do within the host OS.



13.

