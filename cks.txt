1. Secure an Ingress:

Ingress docs, scroll to TLS.
Create a secret with our cert and key.
in Ingress:

spec:
  tls:
  - hosts:
    - https-example.foo.com
    secretName: testsecret-tls
  - host: https-example.foo.com
    http:
      paths:
      - path: /
        pathType: Prefix
        backend:
          service:
            name: service1
            port:
              number: 80

k create secret tls secure-ingress --cert=cert.pem --key=key.pem

2. kube-bench

kube-bench run --targets master
kube-bench run --targets master --check 1.2.20


3. sha512

sha512sum filename > compare
paste second line
cat compare | uniq

4. binaries
tar xzf binary
kubernetes/server/bin/kube-apivserver --version
sha512sum kubernetes/server/bin/kube-apivserver
crictl ps | grep api
ps aux | grep kube-apivserver - see pid
ls /proc/1843/root/ - root fs of the container
find /proc/1843/root/ | grep kube-apivserver
shasum it, append to compare filename

whereis kubelet

5. certs

COMMON NAME: 60099@internal.users

openssl x509 -req -in 60099.csr -CA /etc/kubernetes/pki/ca.crt -CAkey /etc/kubernetes/pki/ca.key -CAcreateserial -out 60099.crt -days 500

cat jane.csr | base64 -w 0

k get csr jane -o yaml (copy certificate)
echo certificate | base64 -d > jane.crt

k config view
users:
-

k config set-credentials jane --client-key=jane.key --client-certificate=jane.crt 
or same with --embed-certs to include certs in kubeconfig

k config set-context jane --user=jane --cluster=kubernetes

k config get-contexts, k config use-context jane

k auth can-i

6. view and list

list secrets - also will access data with -o yaml!

7. sa

k create sa accessor
k create token accessor (pretty temporary)

copy token and paste in into a jwt inspector (jwt.io)

under pod spec:
serviceAccountName: 

token is mounted into a specific directory
mount | grep ser
will contain a token

kubectl -n one exec -it pod-one -- mount | grep serviceaccount

kubectl -n one exec -it pod-one -- cat /var/run/secrets/kubernetes.io/serviceaccount/token

env | grep KUBER 

curl https://10.96.0.1 -k (will identify as anonymous, error)

curl https://10.96.0.1 -k -H "Authorization: Bearer $(cat token)" (still forbidden, but we see auth as default accessor)

If we give RBAC to accessor, it will work.

8. Disabling SA mounting in pod 

Most often we don't need the pod to communicate with the API.

In SA:
automountServiceAccountToken: false

In Pod:
automountServiceAccountToken: false

9. Limit SAs using RBAC to edit resources

By default default sa doesn't really have permissions.
But if someone modifies it, it goes bad.
Better to use custom SAs.

We have a pod with accessor SA.

k auth can-i delete secret --as system:serviceaccount:default:accessor
can't

k create clusterrolebinding accessor --clusterrole edit --serviceaccount default:accessor

k auth ...
yes

10. Restrict API access

Authentication -> Authorization -> Admission Control

Restrictions:
- don't allow anonymous access
- close insecure port 
- don't expose ApiServer to the outside
- restrict access from Nodes to API (NodeRestriction)
- prevent unauthorized access (RBAC)
- prevent pods from accessing API
- Apiserver port behind firewall / allowed ip ranges (cloud provider)

11. Anonymous access 

kube-apiserver --anonymous-auth=true
Anonymous enabled by default, but:
- of auth mode other than Always allow
- but ABAC and RBAC require explicit auth for anonymous 

APIServer needs anonymous auth for liveness probes!

12. Insecure access

No longer possible since 1.20 (kube-apiserver --insecure-port 8080)

13. Manual API Request

k config view --raw = vim .kube/config

Extract certificate-authority-data 
echo ... | base64 -d -w 0 > ca
Same with client-certificate-data
echo ... | base64 -d -w 0 > crt 
client-key-data
echo ... | base64 -d -w 0 > key

k config view 
grab the server address : 6443

curl https://10.154.0.2:5443 --cacert ca
Works, authed as system:anonymous

curl https://10.154.0.2:5443 --cacert ca --cert crt --key=key
Authed as the administrator

14. External APIServer access

k edit svc kubernetes
edit as nodeport 

Remember need open firewall

k config view --raw
copy it to local machine conf file 
change server to external ip 
Cert is not valid for this IP.
openssl x509 -in /etc/kubernetes/pki/apiserver.crt
create a hosts entry in hosts file for the extrenal ip address as kubernetes 
in config file change to kubernetes too
Works!

15. NodeRestriction AdmissionController

kube-apiserver --enable-admission-plugins=NodeRestriction

Limits the Node labels a kubelet can modify
Can only modify certain labels (its only node labels, only labels of pods running on the same node)
Secure workload isolation via labels
No one can pretend to be a "secure" node and schedule "secure" pods

Verify it works:
vi /etc/kubernetes/manifests/kube-apiserver.yaml
--enable-admission-plugins=NodeRestriction (should be by default with kubeadm)
On worker node:
k config view
vi /etc/kubernetes/kubelet.conf - config for kubelet-apiserver communication
export KUBECONFIG=/etc/kubernetes/kubelet.conf - now its our kubectl config 
k get ns - no permissions (user system:node:nodename)
k get node - works 
k label node cks-master cks/test=yes - forbidden 
k label node cks-worker cks/test=yes - works 
Restricted labels we can't even set for ourselves
k label node cks-worker node-restriction.kubernetes.io/test=yes - not allowed to

16. Wrap up of auth

Outside -> API
Pod -> API
Node -> API

Anonymous access
Insecure access
Certificates

17. Secrets

ETCDCTL_API=3 etcdctl ...certs... get /registry/secrets/default/secret2

ETCD ENCRYPTION

Create an EncryptionConfiguration

apiVersion: apiserver.config.k8s.io/v1
kind: EncryptionConfiguration
resources:
  - resources:
    - secrets
    providers:
    - identity: {} kind of deafult provider, nothing is encrypted - plain text
    - aesgcm: encryption method 
        keys:
      - name: key1
        secret: adsfhljksadgh==
      - name: key2
        secret: adfhljkhdsf==
    - aescbc:
        keys:
        - name: key1
          secret: adfhlkjh==
        - name: key2
          secret: adksjfhd==

pass it as an argument to the APIServer
--encryption-provider-config - path to file ^

Encryption config (provider section) works in order!
First one is used on new resource save.

Might do resoruces: - secrets, first aesgcm, later identity as fallback

Need a provider to read! That's why leave identity: {} !!!

Encrypt all after change:
kubectl get secrets --all-namespaces -o json | kubectl replace -f -

Decrypt all: first set provider, second encrypted and recreate all like previously.





